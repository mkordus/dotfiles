set nocompatible

filetype off "required by plugin manager

call plug#begin('~/.vim/plugged')
Plug 'scrooloose/nerdtree'
Plug 'jistr/vim-nerdtree-tabs'

Plug 'kien/ctrlp.vim'
Plug 'DavidEGx/ctrlp-smarttabs'

" Plug 'altercation/vim-colors-solarized'
" Plug 'dhruvasagar/vim-railscasts-theme'
Plug 'morhetz/gruvbox'

Plug 'tomtom/tcomment_vim'
Plug 'spf13/vim-autoclose', { 'on': [] }
Plug 'tpope/vim-surround', { 'on': [] }
" Plug 'kien/rainbow_parentheses.vim', { 'for': ['php', 'sql']}
Plug 'lilydjwg/colorizer'

Plug 'itchyny/lightline.vim'
Plug 'amiorin/vim-project'

Plug 'vim-scripts/dbext.vim', { 'for': ['php', 'sql']}
Plug 'scrooloose/syntastic', { 'for': ['php', 'javascript', 'python']}
Plug 'Valloric/YouCompleteMe', { 'on': [] }
Plug 'SirVer/ultisnips', { 'on': [] }
Plug 'honza/vim-snippets', { 'on': [] }
Plug 'tpope/vim-fugitive'
Plug 'majutsushi/tagbar'
Plug 'mileszs/ack.vim'

Plug 'helino/vim-json', { 'for': ['json']}
Plug 'evidens/vim-twig', { 'for': ['twig']}

Plug 'jelera/vim-javascript-syntax', { 'for': ['javascript']}
Plug 'pangloss/vim-javascript', { 'for': ['javascript']}
call plug#end()

filetype plugin indent on

"lazy loading
augroup load_us_ycm
    autocmd!
    autocmd InsertEnter *
        \ call plug#load('ultisnips', 'vim-snippets', 'YouCompleteMe')
        \| call plug#load('vim-autoclose', 'vim-surround')
        \| call youcompleteme#Enable() | autocmd! load_us_ycm
augroup END

"vim-autoclose
let g:autoclose_vim_commentmode = 1

"main
set encoding=utf-8
set undolevels=1000

set showmatch
set showmode
set showcmd

let g:mapleader = "\<Space>"
inoremap jk <Esc>
inoremap kj <Esc>
nmap <leader>ev :edit $MYVIMRC<CR>
nmap <leader>ws :w !sudo tee %<CR>

set number
set ttyfast

map j gj
map k gk

set splitbelow
set splitright

nmap <leader>h :noh<CR>

"command line mode
set wildmenu
set wildmode=longest:list,full
set wildignorecase
set wildignore+=*/.git/*,*/tmp/*,*/cache/*

"colors
syntax enable
colorscheme gruvbox
set background=dark
if !has('gui_running')
  set t_Co=256
endif

"indent
set autoindent
set copyindent
set smartindent
set smarttab
set expandtab
set shiftwidth=4
set tabstop=4
set et

"gVim options
set guioptions-=T
set guioptions-=r
set guioptions-=L
set guioptions-=m
set guioptions-=e
set showtabline=0
set guifont=Liberation\ Mono\ for\ Powerline\ 11
set mousehide

"searching
set ignorecase
set smartcase
set incsearch
set magic

"Don't redraw while executing macros(performace)
set lazyredraw

"no anoying sound on errors
set noerrorbells
set novisualbell

"turn off backup
set nobackup
set noswapfile
set nowb

set lbr
set tw=500
set nowrap

"nerdtree
nnoremap <leader>n :NERDTreeTabsToggle<CR>
nnoremap <leader>r :NERDTreeFind<CR>
let g:NERDTreeShowHidden=1
let g:NERDTreeChDirMode = 2
let g:nerdtree_tabs_open_on_gui_startup = 0
let g:NERDTreeWinSize = 30

"smart way to move between windows
nnoremap <C-j> <C-W>j
nnoremap <C-k> <C-W>k
nnoremap <C-h> <C-W>h
nnoremap <C-l> <C-W>l
nnoremap <leader>v <C-w>v<C-w>l
nnoremap <leader>s <C-w>s

"speed up scrolling
set scrolljump=8

" Instead of 1 line, move 5 at a time
nnoremap <C-e> 5<C-e>
nnoremap <C-y> 5<C-y>

" wrapping lines in visual mode
vnoremap < <gv
vnoremap > >gv

" DBGPavim
let g:dbgPavimPort = 9000
let g:dbgPavimBreakAtEntry = 0

" tagbar
nnoremap <leader>l :TagbarToggle<CR>
nnoremap <leader>t :TagbarOpenAutoClose<CR>
let g:tagbar_width = 45

" use system clipboard instead of default vim
set clipboard=unnamedplus

" YCM
set completeopt=menuone,longest

"ultiSnips
let g:UltiSnipsSnippetDirectories = ["UltiSnips", "ultisnips-snippets"]
let g:UltiSnipsJumpForwardTrigger="<c-j>"
let g:UltiSnipsJumpBackwardTrigger = "<c-k>"
let g:UltiSnipsExpandTrigger="<S-CR>"

"fugitive
nnoremap <silent> <leader>gs :Gstatus<CR>
nnoremap <silent> <leader>gd :Gvdiff<CR>

"project
let g:project_use_nerdtree = 1
set rtp+=~/.vim/bundle/vim-project/
call project#rc("~/projects")

"ctrlP
let g:ctrlp_working_path_mode = 'rw'
nnoremap <Leader>b :CtrlPBuffer<CR>
nnoremap <C-T> :CtrlPSmartTabs<CR>

if executable('ag')
    let s:ctrlp_fallback = 'ag %s --nocolor -l -g ""'
elseif executable('ack-grep')
    let s:ctrlp_fallback = 'ack-grep %s --nocolor -f'
elseif executable('ack')
    let s:ctrlp_fallback = 'ack %s --nocolor -f'
else
    let s:ctrlp_fallback = 'find %s -type f'
endif

"syntastic
let g:syntastic_php_checkers = ['php']
let g:syntastic_check_on_open=0

"local config
if filereadable(expand('~/dotfiles/vim/vimrc.local'))
    source ~/dotfiles/vim/vimrc.local
endif

"markdown syntax fix
au BufRead,BufNewFile *.md set filetype=markdown

" fast windows close
inoremap <C-q> <esc>:q<cr>
nnoremap <C-q> :q<cr>

" sql
let g:php_sql_query=1

function! ClearSQLSchema()
    execute 'g/^--\|^GRANT\|^REVOKE\|OWNER\|PRIVILEGES FOR ROLE\|^$/d'
    execute 'g/CREATE /\n\0/'
endfunction

"trailing whitespace
autocmd FileType sql,php,vim autocmd BufWritePre <buffer> :%s/\s\+$//e

"rainbow parentheses
" au VimEnter sql,php,vim RainbowParenthesesToggle
" au Syntax sql,php,vim RainbowParenthesesLoadRound
" au Syntax sql,php,vim RainbowParenthesesLoadSquare
" au Syntax sql,php,vim RainbowParenthesesLoadBraces

"better selection
nnoremap gG ggVG

"select php heredoc
vnoremap ih <ESC>?<<<<CR>jV/SQL;<CR>k

"lightline
let g:lightline = {
    \ 'colorscheme': 'powerline',
    \ 'active': {
    \   'left': [ [ 'mode' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
    \   'right': [ [ 'syntastic' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
    \ },
    \ 'component_function': {
    \   'fugitive': 'MyFugitive',
    \   'filename': 'MyFilename',
    \   'fileformat': 'MyFileformat',
    \   'filetype': 'MyFiletype',
    \   'fileencoding': 'MyFileencoding',
    \   'mode': 'MyMode',
    \   'ctrlpmark': 'CtrlPMark',
    \ },
    \ 'component_expand': {
    \   'syntastic': 'SyntasticStatuslineFlag',
    \ },
    \ 'component_type': {
    \   'syntastic': 'error',
    \ },
    \ 'separator': { 'left': '', 'right': '' },
    \ 'subseparator': { 'left': '', 'right': '' }
    \ }

function! MyModified()
  return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
  return &ft !~? 'help' && &readonly ? '' : ''
endfunction

function! MyFilename()
  let fname = expand('%:t')
  return fname == 'ControlP' ? g:lightline.ctrlp_item :
        \ fname == '__Tagbar__' ? g:lightline.fname :
        \ fname =~ '__Gundo\|NERD_tree' ? '' :
        \ &ft == 'vimfiler' ? vimfiler#get_status_string() :
        \ &ft == 'unite' ? unite#get_status_string() :
        \ &ft == 'vimshell' ? vimshell#get_status_string() :
        \ ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        \ ('' != fname ? fname : '[No Name]') .
        \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFugitive()
  try
    if expand('%:t') !~? 'Tagbar\|Gundo\|NERD' && &ft !~? 'vimfiler' && exists('*fugitive#head')
      let mark = ''  " edit here for cool mark
      let _ = fugitive#head()
      return strlen(_) ? mark._ : ''
    endif
  catch
  endtry
  return ''
endfunction

function! MyFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
  return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
  let fname = expand('%:t')
  return fname == '__Tagbar__' ? 'Tagbar' :
        \ fname == 'ControlP' ? 'CtrlP' :
        \ fname == '__Gundo__' ? 'Gundo' :
        \ fname == '__Gundo_Preview__' ? 'Gundo Preview' :
        \ fname =~ 'NERD_tree' ? 'NERDTree' :
        \ &ft == 'unite' ? 'Unite' :
        \ &ft == 'vimfiler' ? 'VimFiler' :
        \ &ft == 'vimshell' ? 'VimShell' :
        \ winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! CtrlPMark()
  if expand('%:t') =~ 'ControlP'
    call lightline#link('iR'[g:lightline.ctrlp_regex])
    return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
          \ , g:lightline.ctrlp_next], 0)
  else
    return ''
  endif
endfunction

let g:ctrlp_status_func = {
  \ 'main': 'CtrlPStatusFunc_1',
  \ 'prog': 'CtrlPStatusFunc_2',
  \ }

function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
  let g:lightline.ctrlp_regex = a:regex
  let g:lightline.ctrlp_prev = a:prev
  let g:lightline.ctrlp_item = a:item
  let g:lightline.ctrlp_next = a:next
  return lightline#statusline(0)
endfunction

function! CtrlPStatusFunc_2(str)
  return lightline#statusline(0)
endfunction

set gcr=a:block

" mode aware cursors
set gcr+=o:hor50-Cursor
set gcr+=n:Cursor
set gcr+=i-ci-sm:InsertCursor
set gcr+=r-cr:ReplaceCursor-hor20
set gcr+=c:CommandCursor
set gcr+=v-ve:VisualCursor

set gcr+=a:blinkon0

hi InsertCursor  ctermfg=15 guifg=#fdf6e3 ctermbg=37  guibg=#2aa198
hi VisualCursor  ctermfg=15 guifg=#fdf6e3 ctermbg=125 guibg=#d33682
hi ReplaceCursor ctermfg=15 guifg=#fdf6e3 ctermbg=65  guibg=#dc322f
hi CommandCursor ctermfg=15 guifg=#fdf6e3 ctermbg=166 guibg=#cb4b16

"gruvbox colorscheme
let g:gruvbox_invert_selection=0
