" vi: fdm=marker

source ~/dotfiles/vim/config/plug.vim
source ~/dotfiles/vim/config/settings.vim
source ~/dotfiles/vim/config/autocmd.vim

if filereadable(expand('~/dotfiles/vim/vimrc.local'))
    source ~/dotfiles/vim/vimrc.local
endif

" Colorscheme: {{{

    if !has('nvim')
        set t_Co=256
    endif
    syntax enable
    set bg=light
    colorscheme solarized

" }}}

" JavascriptLibrariesSyntax: {{{
let g:used_javascript_libs = 'jquery,angularjs,jasmine'
" }}}
" Tagbar: {{{
let g:tagbar_width = 85
let g:tagbar_compact = 1
let g:tagbar_sort = 0
" }}}
" UltiSnips: {{{
" cannot use '<nop>' in ultisnips mappings
let g:UltiSnipsExpandTrigger = "<tab>"
let g:UltiSnipsJumpForwardTrigger="<tab>"
let g:UltiSnipsJumpBackwardTrigger = "<c-b>"
let g:UltiSnipsEditSplit = "vertical"

" let g:ulti_expand_or_jump_res = 0
" function! ExpandSnippetOrCarriageReturn()
"     call UltiSnips#ExpandSnippetOrJump()
"     if g:ulti_expand_or_jump_res == 0
"         return "\<CR>"
"     else
"         return ""
"     endif
" endfunction
" imap <silent> <expr> <CR> "\<C-R>=ExpandSnippetOrCarriageReturn()\<CR>"
" }}}
" Syntastic: {{{
let g:syntastic_php_checkers = ['php']
let g:syntastic_check_on_open=0
let g:syntastic_enable_signs=0
let g:syntastic_always_populate_loc_list=0
" }}}
" YouCompleteMe: {{{
let g:ycm_collect_identifiers_from_comments_and_strings = 1
let g:ycm_complete_in_comments = 1
let g:ycm_complete_in_strings = 1
let g:ycm_global_ycm_extra_conf = '~/dotfiles/vim/ycm_extra_conf.py'
let g:ycm_seed_identifiers_with_syntax = 1
let g:ycm_use_ultisnips_completer = 1
let g:ycm_key_list_previous_completion = ['<c-k>']
let g:ycm_key_list_select_completion = ['<c-j>']

let g:ycm_semantic_triggers = {}
" let g:ycm_semantic_triggers.php = ['->', '::', '(', 'namespace ', '\', 'use ', 'extends ']
let g:ycm_semantic_triggers.php = ['->', '::', 'extends ']

" }}}
" WinResizer: {{{
let g:winresizer_start_key = '<Leader>wr'
let g:winresizer_vert_resize=3
let g:winresizer_horiz_resize=3
" }}}
" ACK: {{{
let g:ackprg = 'ag --nogroup --nocolor --column'
" }}}
" Oblique: {{{
let g:oblique#incsearch_highlight_all=1
" }}}
" DBext: {{{
function! DBextPostResult(db_type, buf_nr)
    set syntax=sql
endfunction
" }}}
" Eclim: {{{
let g:EclimCompletionMethod = 'omnifunc'
let g:EclimPhpValidate = 0
let g:EclimHtmlValidate = 0

" }}}
" FZF: {{{
" let g:fzf_layout = {'window': 'enew'}
let g:fzf_launcher = 'urxvt -title fzf-picker -geometry 110x40+300+100 -e sh -c %s'

command! FZFMruWithoutCwd call fzf#run({
    \'source': "cat ~/.vim_mru_files | tail -n +2 | egrep -v '(^/tmp/|\\.vim_mru_files$)' | grep -v '/.git/' | egrep -v '^" . getcwd() . "'",
    \'sink' : 'e',
    \'options': '-x -m',
    \})

command! FZFMruCwd call fzf#run({
    \'source': "cat ~/.vim_mru_files | tail -n +2 | grep -v '/.git/' |grep '" . getcwd() ."' | sed 's/^" . escape(getcwd(), '/') . "\\///'",
    \'sink' : 'e',
    \'options': '-x -m',
    \})

command! FZFGitCheckoutBranch call fzf#run({
    \'source': 'git branch | sed "s/\#/\\\#/g" | sed "s/\s//g" | sed "/^\*/d"',
    \'sink' : ':silent !git checkout ',
    \'down' : '50%',
    \'options': '-x',
    \})

function! FZFTagClass(initialQuery)
    if !empty(tagfiles()) | call fzf#run({
        \'source': "cat " . join(tagfiles()) . ' | ~/dotfiles/pickClass.sh',
        \'sink': function('EditTag'),
        \'window': 'enew',
        \'options': '--ansi -e --tiebreak=begin --query=' . a:initialQuery
    \}) | else | echo 'No tags' | endif
endfunction

command! FZFTagClassC call FZFTagClass('')

function! EditTag(line)
    execute 'edit ' . matchstr(a:line, '[^ ]\+$')
endfunction

command! FZFFind call fzf#run({
    \'sink': 'e',
    \'options': '-x -m',
    \'window': 'enew'
\})

command! FZFCurrentWindow call fzf#run({
    \'sink' : 'e',
    \'window': 'enew'
\})

command! FZFClassFile call fzf#run({
    \'sink': 'e',
    \'options': '-x -m',
    \'dir': 'src/main/java'
\})

command! FZFTestFile call fzf#run({
    \'sink': 'e',
    \'options': '-x -m',
    \'dir': 'src/test/java'
\})

function! s:buflist()
    redir => ls
    silent ls
    redir END
    return split(substitute(substitute(ls, '\s*wiersz \d\+\s*', '', 'g'), '"', '', 'g'), '\n')
endfunction

function! s:bufopen(e)
    execute 'buffer' matchstr(a:e, '^[ 0-9]*')
endfunction

command! FZFBuffer call fzf#run({
    \   'source':  reverse(<sid>buflist()),
    \   'sink':    function('<sid>bufopen'),
    \   'options': '+m -x',
    \   'down' : '50%',
    \ })

" }}}
" FileBeagle: {{{
let g:filebeagle_suppress_keymaps = 1
" }}}
" BufferExplorer: {{{
let g:bufExplorerDefaultHelp=0
let g:bufExplorerDisableDefaultKeyMapping=1
let g:bufExplorerReverseSort=0
let g:bufExplorerShowNoName=1
let g:bufExplorerShowRelativePath=1
let g:bufExplorerFindActive=0
" }}}
" Goyo: {{{
let g:goyo_width = 120
" }}}
" Sneak: {{{
let g:sneak#s_next = 1
" }}}
" GitGutter: {{{
let g:gitgutter_enabled = 0
let g:gitgutter_signs = 1
let g:gitgutter_highlight_lines = 1
" let g:gitgutter_sign_column_always = 1
let g:gitgutter_max_signs = 1500
let g:gitgutter_map_keys = 0
nnoremap ]c :GitGutterNextHunk<CR>zz
nnoremap [c :GitGutterPrevHunk<CR>zz
nnoremap <leader>gp :GitGutterPreviewHunk<CR>
nnoremap cog :GitGutterToggle<CR>
" }}}
" KeyBindings: {{{
"hard mode :)
noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>

let g:mapleader = "\<Space>"

noremap j gj
noremap k gk

command! WS :w !sudo tee %<CR>

command! Json :%!python -m json.tool

nnoremap <leader>ws <c-w>s
nnoremap <leader>wv <c-w>v
nnoremap <leader>wh <c-w>H
nnoremap <leader>wj <c-w>J
nnoremap <leader>wk <c-w>K
nnoremap <leader>wl <c-w>L
nnoremap <leader>wo <c-w>o

" inoremap kj <esc>
inoremap jk <esc>

nnoremap <leader>h <c-w>h
nnoremap <leader>j <c-w>j
nnoremap <leader>k <c-w>k
nnoremap <leader>l <c-w>l

nnoremap <leader>n :A<CR>

nmap <c-w>m <c-w>_

nmap <silent> <c-d> :silent call CloseWindowOrKillBuffer()<CR>

":echo expand('%:t')<CR>
nmap <silent> <c-p> :silent bp<CR>
nmap <silent> <c-n> :silent bn<CR>

" Instead of 1 line, move 5 at a time
nnoremap <C-e> 10<C-e>
nnoremap <C-y> 10<C-y>

" wrapping lines in visual mode
vnoremap < <gv
vnoremap > >gv

nnoremap <leader>t :BTags!<CR>
nnoremap <leader>T :TagbarOpenAutoClose<CR>

nnoremap <silent> <leader>gs :Gstatus<CR>
nnoremap <silent> <leader>gvd :Gvdiff<CR>
nnoremap <silent> <leader>gd :Git! diff<CR>
nnoremap <silent> <leader>gds :Git! diff --staged<CR>
nnoremap <silent> <leader>gda :Git! diff HEAD<CR>
nnoremap <silent> <leader>gb :Gblame<CR>
nnoremap <silent> <leader>glc :silent Glog -n 10 --no-merges<CR>:copen<CR>
nnoremap <silent> <leader>glp :silent Glog -n 10 --no-merges -- %<CR>

nnoremap <leader>a :Ag! <right>

nnoremap <leader>y :YcmDiags<CR>
" nnoremap <leader>e :Errors<CR>

nnoremap <Leader>ff :FZFFind<CR>
" nnoremap <Leader>ff :Unite -no-split -start-insert file_rec/async<CR>
nnoremap <leader>fl :FZFMruWithoutCwd<CR>
nnoremap <leader>fm :FZFMruCwd<CR>
" nnoremap <leader>fc :FZFClassFile<CR>
nnoremap <leader>s :BLines!<CR>

" nnoremap <Esc>P P'[v']=
" nnoremap <Esc>p p'[v']=

nnoremap <C-\> :vsplit<CR>:let word=expand("<cword>")<CR>:exec "tag" word<CR>

nnoremap gb :FZFBuffer<CR>
nnoremap <leader>gc :FZFGitCheckoutBranch<CR>

map Q @q

" highlight last inserted text
nnoremap gV `[v`]

nnoremap > ]mzt
nnoremap < [mzt

map <silent> _ <Plug>FileBeagleOpenCurrentWorkingDir
map <silent> - <Plug>FileBeagleOpenCurrentBufferDir
nmap <silent> H <Plug>FileBeagleOpenCurrentBufferDir

nnoremap <leader>c :FZFTagClassC<CR>
nnoremap <Leader>b :Buffers!<CR>

" nnoremap <leader>sld :DBExecSQL SELECT datname as "List of databases" FROM pg_database WHERE not datistemplate ORDER BY datname<CR>

nnoremap <silent><leader>o :silent Unite -no-split buffer<CR>
nnoremap <leader>go :Goyo<CR>

nnoremap <silent>L :silent b#<CR>
" nnoremap <silent>L :silent LustyBufferExplorer<CR>

" nmap s <Plug>Sneak_s
" nmap S <Plug>Sneak_S
" xmap s <Plug>Sneak_s
" xmap S <Plug>Sneak_S
" omap s <Plug>Sneak_s
" omap S <Plug>Sneak_S

" "replace 'f' with 1-char Sneak
nmap f <Plug>Sneak_f
nmap F <Plug>Sneak_F
xmap f <Plug>Sneak_f
xmap F <Plug>Sneak_F
omap f <Plug>Sneak_f
omap F <Plug>Sneak_F

"replace 't' with 1-char Sneak
nmap t <Plug>Sneak_t
nmap T <Plug>Sneak_T
xmap t <Plug>Sneak_t
xmap T <Plug>Sneak_T
omap t <Plug>Sneak_t
omap T <Plug>Sneak_T

" nnoremap s :BufExplorer<CR>
nnoremap <silent><c-s> :silent w<CR>:call TmuxRepeat()<CR>

if has('nvim')
    " tnoremap <C-h> <C-\><C-n><C-w>h
    " tnoremap <C-j> <C-\><C-n><C-w>j
    " tnoremap <C-k> <C-\><C-n><C-w>k
    " tnoremap <C-l> <C-\><C-n><C-w>l
    tnoremap <ESC><ESC> <C-\><C-n>
endif

augroup Terminal
    au!
    au WinEnter term://* startinsert
augroup END

" nnoremap <C-]> <Esc>:exe "ptjump " . expand("<cword>")<Esc>

nnoremap ; :
" }}}
" Other: {{{
command! -nargs=1 Silent
    \ | execute ':silent !'.<q-args>
    \ | execute ':redraw!'

function! GetGitRootDir()
    let filePath = expand('%:p:h')
    let shellcmd = 'cd ' . filePath . ';'
        \ . 'basename $(readlink -f $(git rev-parse --show-cdup))'
        \ . '| sed "s/[ \r\n]//g"'

    return system(shellcmd)
endfunction

" nnoremap gp gg/\(extends\\|implements\) /e<CR>l<C-]>

function! OpenFileInLastWindow(shouldStayInPlugin)
    let line = substitute(getline('.'), '.\{-}\(\([0-9A-Za-z_-]\+/\)\+[0-9A-Za-z_-]\+\.\?[0-9A-Za-z_-]\+\(:\d\+\)\?\( on line \d\+\)\?\).*', '\1', '')
    let line = substitute(line, ' on line \(\d\+\)', ':\1', '')
    if line != getline('.')
        echo line
        let filePath = split(line, ':')

        if a:shouldStayInPlugin
            let sip = 'noautocmd wincmd p'
        else
            let sip = ''
        endif

        if len(filePath) == 2
            silent! exe "noautocmd wincmd p | e +" . filePath[1] . " " . filePath[0]
            normal! zz
            exe sip
        else
            silent! exe "noautocmd wincmd p | e " . filePath[0]
            exe sip
        endif
    endif
endfunction

function! RunPHPUnitTest(filter)
    if a:filter
        let args = 'src'
    else
        let args = expand("%")
    endif

    if filereadable("app/phpunit.xml.dist")
        let configPath = '-c app '
    else
        let configPath = ''
    endif

    let result = system('bin/phpunit ' . configPath . args . ' | ~/dotfiles/colorize_phpunit.sh > swap.tmp &')
endfunction

function! ToggleTest()
    let isTest = bufname('%') =~ 'Test.php$'

    let filePath = expand('%:p') if isTest
        let filePath = substitute(filePath, "BriefcaseBundle/Tests", "BriefcaseBundle", "")
        let filePath = substitute(filePath, "Test.php$", ".php", "")
    else
        let filePath = substitute(filePath, "BriefcaseBundle", "BriefcaseBundle/Tests", "")
        let filePath = substitute(filePath, ".php$", "Test.php", "")
    endif

    execute 'edit' filePath
endfunction

" nnoremap <leader>i :call RunPHPUnitTest(0)<cr>
" nnoremap <leader>o :call RunPHPUnitTest(1)<cr>
" nnoremap <leader>i :execute(':silent JUnit %') \| redraw!<CR>
nnoremap <leader>i :JUnit %<CR>

nnoremap gf gF

" nnoremap K :call ToggleTest()<CR>
nnoremap K :A<CR>
" Return to last edit position when opening files (You want this!)
" autocmd BufReadPost *
"      \ if line("'\"") > 0 && line("'\"") <= line("$") |
"      \   exe "normal! g`\"" |
"      \ endif
" Remember info about open buffers on close
" set viminfo^=%

function! CloseWindowOrKillBuffer() "{{{
    let number_of_windows_to_this_buffer = len(filter(range(1, winnr('$')), "winbufnr(v:val) == bufnr('%')"))

    " never bdelete a nerd tree
    " if matchstr(expand("%"), 'NERD') == 'NERD'
    "   wincmd c
    "   return
    " endif

    if number_of_windows_to_this_buffer > 1
      wincmd c
    else
      bdelete
    endif
endfunction "}}}

fun! LuciousLightColors()
    set background=light
    " LuciusLightHighContrast
    LuciusLight
    " hi CursorLineNr ctermbg=cyan
    " hi StatusLine ctermbg=cyan ctermfg=black
    hi! Search ctermfg=238 ctermbg=153
    hi! LineNr ctermfg=247 ctermbg=254
    hi! SignColumn ctermbg=254
    hi! Folded ctermfg=67 ctermbg=254 cterm=none
    hi! StatusLine   ctermfg=255 ctermbg=246 cterm=none
    hi! StatusLineNC ctermfg=254 ctermbg=246 cterm=none
    hi! VertSplit ctermfg=244 ctermbg=254
    hi! User1 ctermfg=119 ctermbg=246 cterm=none
    hi! User2 ctermfg=1 ctermbg=246 cterm=bold
endfun

" call LuciousLightColors()

fun! LuciousDarkColors()
    set background=dark
    LuciusDark
endfun
" }}}

function! NeatFoldText() "{{{2
"http://dhruvasagar.com/2013/03/28/vim-better-foldtext
  let line = ' ' . substitute(getline(v:foldstart), '^\s*"\?\s*\|\s*"\?\s*{{' . '{\d*\s*', '', 'g') . ' '
  let lines_count = v:foldend - v:foldstart + 1
  let lines_count_text = '| ' . printf("%10s", lines_count . ' lines') . ' |'
  let foldchar = matchstr(&fillchars, 'fold:\zs.')
  let foldtextstart = strpart('+' . repeat(foldchar, v:foldlevel*2) . line, 0, (winwidth(0)*2)/3)
  let foldtextend = lines_count_text . repeat(foldchar, 8)
  let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
  return foldtextstart . repeat(foldchar, winwidth(0)-foldtextlength) . foldtextend
endfunction
set foldtext=NeatFoldText()
" }}}2

function! GetBasePath()
    let basePath = expand('%:p:.:h')
    if basePath == '.'
        return ''
    else
        return basePath . '/'
    endif
endfunction

function! GetName()
    let tmpName = expand('%:p:t')
    if strlen(tmpName)
        return substitute(tmpName, '\.\w\+$', '', '')
    else
        return '[No name]'
    endif
endfunction

function! GetExtension()
    let tmpName = expand('%:p:t')
    if strlen(tmpName)
        let extension = substitute(tmpName, '.\{-}\(\.\w\+\)$', '\1', '')
        if strlen(extension) && tmpName != extension
            return extension
        else
            return ''
        endif
    else
        return ''
    endif
endfunction

function! Modified()
    return &modified ? '[+]' : ''
endfunction

function! Padding()
    return '      '
endfunction

set numberwidth=5

"generate getters
vnoremap <leader>g :s/\s*\$\(\w\+\)\W\?/\tpublic function get\u\1()\r\t{\r\t\treturn $this->\1;\r\t}\r/<CR>ddk

nnoremap gp `[v`]

" reverse words order
" '<,'>!while IFS= read -r; do echo -n "$REPLY " | tac -s' '; echo; done
